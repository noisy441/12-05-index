# Домашнее задание к занятию «Индексы» - Дудин Сергей Васильевич

### Инструкция по выполнению домашнего задания

1. Сделайте fork [репозитория c шаблоном решения](https://github.com/netology-code/sys-pattern-homework) к себе в Github и переименуйте его по названию или номеру занятия, например, https://github.com/имя-вашего-репозитория/gitlab-hw или https://github.com/имя-вашего-репозитория/8-03-hw).
2. Выполните клонирование этого репозитория к себе на ПК с помощью команды `git clone`.
3. Выполните домашнее задание и заполните у себя локально этот файл README.md:
   - впишите вверху название занятия и ваши фамилию и имя;
   - в каждом задании добавьте решение в требуемом виде: текст/код/скриншоты/ссылка;
   - для корректного добавления скриншотов воспользуйтесь инструкцией [«Как вставить скриншот в шаблон с решением»](https://github.com/netology-code/sys-pattern-homework/blob/main/screen-instruction.md);
   - при оформлении используйте возможности языка разметки md. Коротко об этом можно посмотреть в [инструкции по MarkDown](https://github.com/netology-code/sys-pattern-homework/blob/main/md-instruction.md).
4. После завершения работы над домашним заданием сделайте коммит (`git commit -m "comment"`) и отправьте его на Github (`git push origin`).
5. После отправки ссылки на решение в виде md-файла в вашем Github в личном кабинете появится эталонный ответ.
6. Любые вопросы задавайте в чате учебной группы и/или в разделе «Вопросы по заданию» в личном кабинете.

Желаем успехов в выполнении домашнего задания.

### Задание 1

Напишите запрос к учебной базе данных, который вернёт процентное отношение общего размера всех индексов к общему размеру всех таблиц.

### Решение 1

```

SELECT 
    ROUND(
        (SUM(index_size) * 100.0 / SUM(table_size)), 
        2
    ) AS index_to_table_ratio_percent
FROM (
    SELECT 
        SUM(data_length + index_length) AS table_size,
        SUM(index_length) AS index_size
    FROM information_schema.tables
    WHERE table_schema = 'sakila'
    GROUP BY table_schema
) AS sizes;

```

![Решение 1](https://github.com/noisy441/12-05-index/blob/main/img/img1.png)

### Задание 2

Выполните explain analyze следующего запроса:
```sql
select distinct concat(c.last_name, ' ', c.first_name), sum(p.amount) over (partition by c.customer_id, f.title)
from payment p, rental r, customer c, inventory i, film f
where date(p.payment_date) = '2005-07-30' and p.payment_date = r.rental_date and r.customer_id = c.customer_id and i.inventory_id = r.inventory_id
```
- перечислите узкие места;
- оптимизируйте запрос: внесите корректировки по использованию операторов, при необходимости добавьте индексы.

### Решение 2

![Решение 2](https://github.com/noisy441/12-05-index/blob/main/img/img2.png)

Узкими местами тут явно являются высокая стоимость запроса, значительное время на сканирование таблицы, большле количество обрабатываемых строк. Оконная функция для подсчета требует большого количества памяти. 

Оптимизируем запрос, для чего переделаем неявные JOIN, немного оптимизируем фильтрацию и будем использовать GROUP BY вместо DISTINCT. Так же добавим индексы на поле payment_date, на поля соединений (customer_id, inventory_id) и на title в таблице film

Переписанный вариант будет выглядеть так:

```

SELECT 
    CONCAT(c.last_name, ' ', c.first_name) AS full_name,
    SUM(p.amount) AS total_amount
FROM payment p
JOIN rental r ON p.payment_date = r.rental_date
JOIN customer c ON r.customer_id = c.customer_id
JOIN inventory i ON i.inventory_id = r.inventory_id
JOIN film f ON i.film_id = f.film_id
WHERE DATE(p.payment_date) = '2005-07-30' 
GROUP BY 
    c.customer_id,
    c.last_name,
    c.first_name,
    f.title;

```

![Решение ](https://github.com/noisy441/12-05-index/blob/main/img/img3.png)

Значительно снизилась стоимость запроса и сократилось время выполнения.

## Дополнительные задания (со звёздочкой*)
Эти задания дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже шире разобраться в материале.

### Задание 3*

Самостоятельно изучите, какие типы индексов используются в PostgreSQL. Перечислите те индексы, которые используются в PostgreSQL, а в MySQL — нет.

*Приведите ответ в свободной форме.*

### Решение 3*

В отличие от PostgreSQL, MySQL поддерживает только базовые типы индексов: B-tree, Hash, Full-text и SPATIAL, что делает PostgreSQL более гибким в плане возможностей индексирования.
В PostgreSQL доступны следующие типы индексов, которых нет в MySQL:

**GIN (Generalized Inverted Index)** — обобщённый инвертированный индекс, который особенно эффективен для полнотекстового поиска, индексации массивов и JSON-данных. Этот тип индекса позволяет быстро выполнять поиск по составным значениям.

**GiST (Generalized Search Tree)** — обобщённое поисковое дерево, которое используется для индексации различных типов данных, включая геометрические объекты, сетевые адреса и полнотекстовый поиск. GiST-индексы поддерживают многомерные поиски.

**SP-GiST (Space-Partitioned Generalized Search Tree)** — пространственно разделённое обобщённое поисковое дерево, оптимизированное для работы с данными, которые имеют естественную иерархическую структуру.

**BRIN (Block Range Index)** — индекс по диапазонам блоков, который эффективен для больших таблиц с естественным порядком данных (например, временные ряды). Он минимизирует использование памяти.

**Bitmap index** — битовый индекс, который создаёт отдельные битовые карты для каждого возможного значения столбца. Каждому биту соответствует строка с индексируемым значением. Значение 1 означает, что запись содержит индексируемое значение.

**Partial index** — частичный индекс, создаваемый только для части таблицы, удовлетворяющей определённому условию. Это позволяет уменьшить размер индекса и ускорить запросы.

**Functional index** — функциональный индекс, хранящий результат пользовательских функций. Особенно полезен для полей, значения которых проходят предварительную обработку перед сравнением (например, сравнение строк без учёта регистра).

